/*************************************************************************
GSM-controlled scrolling LED notice board based on 8x8 Dot Matrix modules   

Version : 1.0
Author  : Mehdi Bolourian
Chip: ATMega32A
IDE: CodeVisionAVR

Open-Source project
*************************************************************************/

#include <mega32a.h>
#include <stdio.h>
#include <string.h>
#include <delay.h>

//The number of LED rows and columns of the notice board
#define ROW_NO 16
#define COL_NO 80

#define SMS_MAX_SIZE 84

//Lock pattern for accessing the notice board
//format of SMS sent to GSM module: "LOCKPATTERN"-"Message" (for example: 1234-Test Message.)
#define LOCK_PATTERN "1234"

#define PHONE_NUMBER_MAX_LENGTH 13

#define true 1
#define false 0

//ASCII code of Ctrl+Z pattern
#define CTRL_Z 0x1A

//Lock of the notice board
bit lock=true;
/*Used to find the second \r character for recognizing
the end of the response string from GSM module*/
bit flag_r=false;
//End-of-string flag
bit flag_eos=true;
/*It determines that microcontroller is ready for SMS or not
false: not ready, true: ready*/ 
bit flag_sms=false;
//For determining the first character of the phone number ('+' character)
bit flag_phone=false;
//Flag to determine where to scroll the notice board
bit flag_scroll=false;
bit flag_first_try=true;
/*Flag to determine the GSM module connection
false: not connected, true: connected*/
bit flag_connected=false;
bit flag_correct_pass=false;

unsigned char counter_lock=0;
unsigned short counter_char=0;
unsigned char counter_phone=0;
unsigned char counter_buffer=0;
unsigned short counter_timer=0;

//Temporary Variables
char temp_uart;
unsigned char tmp1_dot;
unsigned char tmp0_dot;
unsigned char temp1_dot[SMS_MAX_SIZE*8];
unsigned char temp0_dot[SMS_MAX_SIZE*8];

char phone_buffer[PHONE_NUMBER_MAX_LENGTH]; //To store the phone_number
char sms_buffer[SMS_MAX_SIZE]="Testing"; //To store the SMS string

unsigned short size_str=0, i=0, j=0, k=0;

//Font for every character of the notice board
const unsigned char FONT[] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char SPACE 
        0xFF, 0x37, 0xFF, 0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char !
        0x80, 0x1D, 0xC0, 0x3F, 0x40, 0x26, 0xC0, 0x3F, 0x80, 0x19, 0x00, 0x2C, 0x00, 0x24, 0x00, 0x00,  // Code for char &
        0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 0xFC, 0x0F, 0x06, 0x18, 0x03, 0x30, 0x01, 0x20, 0x00, 0x00,  // Code for char (
        0x01, 0x20, 0x03, 0x30, 0x06, 0x18, 0xFC, 0x0F, 0xF8, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char )
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char ,
        0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00,  // Code for char -
        0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char .
        0xFE, 0x1F, 0xFF, 0x3F, 0x63, 0x30, 0xC3, 0x30, 0x83, 0x31, 0xFF, 0x3F, 0xFE, 0x1F, 0x00, 0x00,  // Code for char 0
        0x00, 0x30, 0x0C, 0x30, 0x0C, 0x30, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00,  // Code for char 1
        0x06, 0x3F, 0x87, 0x3F, 0x83, 0x31, 0x83, 0x31, 0x83, 0x31, 0xFF, 0x31, 0xFE, 0x30, 0x00, 0x00,  // Code for char 2
        0x06, 0x18, 0x07, 0x38, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xFF, 0x3F, 0x7E, 0x1F, 0x00, 0x00,  // Code for char 3
        0xF0, 0x00, 0xF8, 0x00, 0xCC, 0x00, 0xC6, 0x00, 0xFF, 0x3F, 0xFF, 0x3F, 0xC0, 0x00, 0x00, 0x00,  // Code for char 4
        0xFF, 0x18, 0xFF, 0x38, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x3F, 0x83, 0x1F, 0x00, 0x00,  // Code for char 5
        0xFC, 0x1F, 0xFE, 0x3F, 0x87, 0x31, 0x83, 0x31, 0x83, 0x31, 0x83, 0x3F, 0x03, 0x1F, 0x00, 0x00,  // Code for char 6
        0x03, 0x3F, 0x83, 0x3F, 0xC3, 0x00, 0x63, 0x00, 0x33, 0x00, 0x1F, 0x00, 0x0F, 0x00, 0x00, 0x00,  // Code for char 7
        0x7E, 0x1F, 0xFF, 0x3F, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xFF, 0x3F, 0x7E, 0x1F, 0x00, 0x00,  // Code for char 8
        0x7E, 0x00, 0xFF, 0x30, 0xC3, 0x30, 0xC3, 0x38, 0xC3, 0x1C, 0xFF, 0x0F, 0xFE, 0x07, 0x00, 0x00,  // Code for char 9
        0x00, 0x6C, 0x00, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char :
        0x0C, 0x00, 0x0E, 0x36, 0x03, 0x37, 0x83, 0x01, 0x83, 0x01, 0xFE, 0x00, 0x7C, 0x00, 0x00, 0x00,  // Code for char ?
        0xE0, 0x0F, 0x30, 0x19, 0xB0, 0x1A, 0xB0, 0x1A, 0xB0, 0x1B, 0x30, 0x1A, 0xE0, 0x01, 0x00, 0x00,  // Code for char @
        0xFC, 0x3F, 0xFE, 0x3F, 0x83, 0x01, 0x83, 0x01, 0x83, 0x01, 0xFE, 0x3F, 0xFC, 0x3F, 0x00, 0x00,  // Code for char A
        0xFF, 0x3F, 0xFF, 0x3F, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xFE, 0x1F, 0x7C, 0x0F, 0x00, 0x00,  // Code for char B
        0xFE, 0x1F, 0xFF, 0x3F, 0x03, 0x30, 0x03, 0x30, 0x03, 0x30, 0x03, 0x30, 0x06, 0x18, 0x00, 0x00,  // Code for char C
        0xFF, 0x3F, 0xFF, 0x3F, 0x03, 0x30, 0x03, 0x30, 0x03, 0x30, 0xFE, 0x1F, 0xFC, 0x0F, 0x00, 0x00,  // Code for char D
        0xFF, 0x3F, 0xFF, 0x3F, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0x07, 0x38, 0x00, 0x00,  // Code for char E
        0xFF, 0x3F, 0xFF, 0x3F, 0x83, 0x01, 0x83, 0x01, 0x83, 0x01, 0x83, 0x01, 0x07, 0x00, 0x00, 0x00,  // Code for char F
        0xFE, 0x1F, 0xFF, 0x3F, 0x03, 0x30, 0x03, 0x30, 0x83, 0x31, 0x87, 0x31, 0x86, 0x3F, 0x00, 0x00,  // Code for char G
        0xFF, 0x3F, 0xFF, 0x3F, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00,  // Code for char H
        0x03, 0x30, 0x01, 0x20, 0xFF, 0x3F, 0xFF, 0x3F, 0xFF, 0x3F, 0x01, 0x20, 0x03, 0x30, 0x00, 0x00,  // Code for char I
        0x03, 0x18, 0x03, 0x30, 0x03, 0x30, 0xFF, 0x3F, 0xFF, 0x1F, 0x03, 0x00, 0x03, 0x00, 0x03, 0x00,  // Code for char J
        0xFF, 0x3F, 0xFF, 0x3F, 0xC0, 0x01, 0x60, 0x03, 0x30, 0x07, 0x1F, 0x3E, 0x0F, 0x3C, 0x00, 0x00,  // Code for char K
        0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x38, 0x00, 0x00,  // Code for char L
        0xFF, 0x3F, 0xFE, 0x3F, 0x1C, 0x00, 0x78, 0x00, 0x1C, 0x00, 0xFE, 0x3F, 0xFF, 0x3F, 0x00, 0x00,  // Code for char M
        0xFF, 0x3F, 0xFF, 0x3F, 0x38, 0x00, 0x70, 0x00, 0xE0, 0x00, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00,  // Code for char N
        0xFE, 0x1F, 0xFF, 0x3F, 0x03, 0x30, 0x03, 0x30, 0x03, 0x30, 0xFF, 0x3F, 0xFE, 0x1F, 0x00, 0x00,  // Code for char O
        0xFF, 0x3F, 0xFF, 0x3F, 0xC3, 0x00, 0xC3, 0x00, 0xC3, 0x00, 0xFF, 0x00, 0x7E, 0x00, 0x00, 0x00,  // Code for char P
        0xFE, 0x1F, 0xFF, 0x3F, 0x03, 0x34, 0x03, 0x3C, 0x03, 0x18, 0xFF, 0x3F, 0xFE, 0x1F, 0x00, 0x00,  // Code for char Q
        0xFF, 0x3F, 0xFF, 0x3F, 0xC3, 0x03, 0xC3, 0x07, 0xC3, 0x0E, 0xFF, 0x3C, 0x7E, 0x38, 0x00, 0x00,  // Code for char R
        0x7E, 0x18, 0xFF, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x30, 0xC3, 0x3F, 0x86, 0x1F, 0x00, 0x00,  // Code for char S
        0x07, 0x00, 0x03, 0x20, 0xFF, 0x3F, 0xFF, 0x3F, 0xFF, 0x3F, 0x03, 0x20, 0x07, 0x00, 0x00, 0x00,  // Code for char T
        0xFF, 0x1F, 0xFF, 0x3F, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0xFF, 0x3F, 0xFF, 0x1F, 0x00, 0x00,  // Code for char U
        0xFF, 0x07, 0xFF, 0x0F, 0x00, 0x18, 0x00, 0x30, 0x00, 0x18, 0xFF, 0x0F, 0xFF, 0x07, 0x00, 0x00,  // Code for char V
        0xFF, 0x3F, 0xFF, 0x7F, 0x00, 0x70, 0x00, 0x3F, 0x00, 0x70, 0xFF, 0x7F, 0xFF, 0x3F, 0x00, 0x00,  // Code for char W
        0x1F, 0x3C, 0x3F, 0x3E, 0x60, 0x03, 0xC0, 0x01, 0x60, 0x03, 0x3F, 0x3E, 0x1F, 0x3C, 0x00, 0x00,  // Code for char X
        0x3F, 0x00, 0x7F, 0x20, 0xC0, 0x3F, 0x80, 0x3F, 0xC0, 0x3F, 0x7F, 0x20, 0x3F, 0x00, 0x00, 0x00,  // Code for char Y
        0x07, 0x3E, 0x03, 0x3F, 0x83, 0x31, 0xC3, 0x30, 0x63, 0x30, 0x3F, 0x30, 0x1F, 0x38, 0x00, 0x00,  // Code for char Z
        0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00,  // Code for char _
        0x00, 0x1C, 0xC0, 0x3E, 0xC0, 0x36, 0xC0, 0x36, 0xC0, 0x36, 0xC0, 0x3F, 0x00, 0x3F, 0x00, 0x00,  // Code for char a
        0xFF, 0x3F, 0xFF, 0x3F, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x3F, 0x80, 0x1F, 0x00, 0x00,  // Code for char b
        0x80, 0x1F, 0xC0, 0x3F, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x30, 0x00, 0x18, 0x00, 0x00,  // Code for char c
        0x80, 0x1F, 0xC0, 0x3F, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x30, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x00,  // Code for char d
        0x80, 0x1F, 0xC0, 0x3F, 0xC0, 0x36, 0xC0, 0x36, 0xC0, 0x36, 0xC0, 0x36, 0x80, 0x07, 0x00, 0x00,  // Code for char e
        0x80, 0x01, 0xFC, 0x3F, 0xFE, 0x3F, 0x87, 0x01, 0x87, 0x01, 0x8E, 0x01, 0x0C, 0x00, 0x00, 0x00,  // Code for char f
        0x80, 0x67, 0xC0, 0xEF, 0xC0, 0xCC, 0xC0, 0xCC, 0xC0, 0xCC, 0xC0, 0xFF, 0xC0, 0x7F, 0x00, 0x00,  // Code for char g
        0xFF, 0x3F, 0xFF, 0x3F, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x3F, 0x00, 0x3F, 0x00, 0x00,  // Code for char h
        0x00, 0x30, 0x00, 0x30, 0x80, 0x31, 0x98, 0x3F, 0xD8, 0x3F, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00,  // Code for char i
        0x00, 0x60, 0x00, 0xE0, 0x00, 0xC0, 0x80, 0xC1, 0x98, 0xC1, 0x98, 0xFF, 0x80, 0x7F, 0x00, 0x00,  // Code for char j
        0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x03, 0x80, 0x07, 0xC0, 0x0C, 0x70, 0x38, 0x30, 0x30, 0x00, 0x00,  // Code for char k
        0x03, 0x00, 0x03, 0x00, 0xFF, 0x3F, 0xFF, 0x3F, 0x00, 0x30, 0x00, 0x30, 0x00, 0x18, 0x00, 0x00,  // Code for char l
        0xC0, 0x3F, 0x80, 0x3F, 0xC0, 0x01, 0x80, 0x07, 0xC0, 0x01, 0x80, 0x3F, 0x00, 0x3F, 0x00, 0x00,  // Code for char m
        0xC0, 0x3F, 0x80, 0x3F, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x3F, 0x00, 0x3F, 0x00, 0x00,  // Code for char n
        0x80, 0x1F, 0xC0, 0x3F, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x3F, 0x80, 0x1F, 0x00, 0x00,  // Code for char o
        0xC0, 0xFF, 0xC0, 0xFF, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0F, 0x80, 0x07, 0x00, 0x00,  // Code for char p
        0x80, 0x07, 0xC0, 0x0F, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0x0C, 0xC0, 0xFF, 0xC0, 0xFF, 0x00, 0x00,  // Code for char q
        0xC0, 0x3F, 0x00, 0x3F, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00,  // Code for char r
        0x80, 0x13, 0xC0, 0x37, 0xC0, 0x36, 0xC0, 0x36, 0xC0, 0x36, 0xC0, 0x3E, 0x80, 0x1C, 0x00, 0x00,  // Code for char s
        0x30, 0x00, 0x30, 0x00, 0xFF, 0x1F, 0xFF, 0x3F, 0x30, 0x30, 0x30, 0x38, 0x30, 0x18, 0x00, 0x00,  // Code for char t
        0xC0, 0x1F, 0xC0, 0x3F, 0x00, 0x30, 0x00, 0x30, 0x00, 0x38, 0xC0, 0x1F, 0xC0, 0x3F, 0x00, 0x00,  // Code for char u
        0xC0, 0x07, 0xC0, 0x0F, 0x00, 0x18, 0x00, 0x30, 0x00, 0x18, 0xC0, 0x0F, 0xC0, 0x07, 0x00, 0x00,  // Code for char v
        0xC0, 0x3F, 0xC0, 0x7F, 0x00, 0x60, 0x00, 0x3C, 0x00, 0x60, 0xC0, 0x7F, 0xC0, 0x3F, 0x00, 0x00,  // Code for char w
        0xC0, 0x30, 0xC0, 0x39, 0x00, 0x0F, 0x00, 0x06, 0x00, 0x0F, 0xC0, 0x39, 0xC0, 0x30, 0x00, 0x00,  // Code for char x
        0xC0, 0x67, 0xC0, 0xEF, 0x00, 0xCC, 0x00, 0xCC, 0x00, 0xCC, 0xC0, 0xFF, 0xC0, 0x7F, 0x00, 0x00,  // Code for char y
        0xC0, 0x30, 0xC0, 0x38, 0xC0, 0x3C, 0xC0, 0x36, 0xC0, 0x33, 0xC0, 0x31, 0xC0, 0x30, 0x00, 0x00,  // Code for char z
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Code for char +
};

//Transforms the input character to its first FONT array firs
unsigned int char_to_FONTindex(char in)
{
    switch (in)
    {
        case ' ': { return 0; break;}
        case '!': { return 1; break;}
        case '&': { return 2; break;}
        case '(': { return 3; break;}
        case ')': { return 4; break;}
        case ',': { return 5; break;}
        case '-': { return 6; break;}
        case '.': { return 7; break;}
        case '0': { return 8; break;}
        case '1': { return 9; break;}
        case '2': { return 10; break;}
        case '3': { return 11; break;}
        case '4': { return 12; break;}
        case '5': { return 13; break;}
        case '6': { return 14; break;}
        case '7': { return 15; break;}
        case '8': { return 16; break;}
        case '9': { return 17; break;}
        case ':': { return 18; break;}
        case '?': { return 19; break;}
        case '@': { return 20; break;}
        case 'A': { return 21; break;}
        case 'B': { return 22; break;}
        case 'C': { return 23; break;}
        case 'D': { return 24; break;}
        case 'E': { return 25; break;}
        case 'F': { return 26; break;}
        case 'G': { return 27; break;}
        case 'H': { return 28; break;}
        case 'I': { return 29; break;}
        case 'J': { return 30; break;}
        case 'K': { return 31; break;}
        case 'L': { return 32; break;}
        case 'M': { return 33; break;}
        case 'N': { return 34; break;}
        case 'O': { return 35; break;}
        case 'P': { return 36; break;}
        case 'Q': { return 37; break;}
        case 'R': { return 38; break;}
        case 'S': { return 39; break;}
        case 'T': { return 40; break;}
        case 'U': { return 41; break;}
        case 'V': { return 42; break;}
        case 'W': { return 43; break;}
        case 'X': { return 44; break;}
        case 'Y': { return 45; break;}
        case 'Z': { return 46; break;}
        case '_': { return 47; break;}
        case 'a': { return 48; break;}
        case 'b': { return 49; break;}
        case 'c': { return 50; break;}
        case 'd': { return 51; break;}
        case 'e': { return 52; break;}
        case 'f': { return 53; break;}
        case 'g': { return 54; break;}
        case 'h': { return 55; break;}
        case 'i': { return 56; break;}
        case 'j': { return 57; break;}
        case 'k': { return 58; break;}
        case 'l': { return 59; break;}
        case 'm': { return 60; break;}
        case 'n': { return 61; break;}
        case 'o': { return 62; break;}
        case 'p': { return 63; break;}
        case 'q': { return 64; break;}
        case 'r': { return 65; break;}
        case 's': { return 66; break;}
        case 't': { return 67; break;}
        case 'u': { return 68; break;}
        case 'v': { return 69; break;}
        case 'w': { return 70; break;}
        case 'x': { return 71; break;}
        case 'y': { return 72; break;}
        case 'z': { return 73; break;}
        case '+': { return 74; break;} 
        default: { return 0; break; }
    }
}

void reset_screen(void)
{
    for(i=0; i<SMS_MAX_SIZE; i++){
        for(j=0; j<ROW_NO/2; j++){
            temp1_dot[ROW_NO/2*i+j]=0;
            temp0_dot[ROW_NO/2*i+j]=0;
        }
    }
}

void scroll_screen(void)
{
    int l=0;
    tmp1_dot=temp1_dot[0];
    tmp0_dot=temp0_dot[0];
    for(l=0; l<(8*(size_str)-1); l++){
        temp1_dot[l]=temp1_dot[l+1];
        temp0_dot[l]=temp0_dot[l+1];
    }
    temp1_dot[8*(size_str)-1]=tmp1_dot;
    temp0_dot[8*(size_str)-1]=tmp0_dot;
}

void init_screen(void)
{
    size_str=strlen(sms_buffer);
    for(i=0; i<size_str; i++){
        for(j=0; j<ROW_NO/2; j++){
            temp1_dot[ROW_NO/2*i+j]=FONT[ROW_NO*char_to_FONTindex(sms_buffer[i])+2*j];
            temp0_dot[ROW_NO/2*i+j]=FONT[ROW_NO*char_to_FONTindex(sms_buffer[i])+2*j+1];
        }
    }
    delay_ms(2000);
}

void gsm_module_init(void)
{   
    printf("AT\r\n");
    delay_ms(10); 
    
    if(!flag_connected && flag_first_try){
        delay_ms(1000);
        flag_first_try=false;
        strcpy(sms_buffer,"GSM module is not properly connected!          ");
        init_screen();
    }
    
    else if(flag_connected){
        delay_ms(1000);
        
        reset_screen();
        
        delay_ms(500);

        printf("ATE0\r\n");
        delay_ms(1000);

        reset_screen();
        
        delay_ms(500);

        printf("AT+CMGF=1\r\n");
        delay_ms(1000);

        reset_screen();
        
        delay_ms(500);

        printf("AT+CNMI=1,2,0,0,0\r\n");
        delay_ms(1000);

        reset_screen();
        
        flag_sms=true;
    }
}

//Timer0 Compare Match Interrupt
interrupt [TIM0_COMP] void timer0_comp_isr(void)
{
    PORTA=0x00;
    PORTC=0x00;        
    PORTB.3=!PORTB.3;
    if(PORTB.3  && flag_eos){  //rising edge of OC0
        if(k<(size_str*8)){
            PORTA=temp0_dot[k-1];
            PORTC=temp1_dot[k-1];
        }
        else{
            PORTA=0x00;
            PORTC=0x00;            
        }
        if(k==0) PORTB.2=1; 
        else PORTB.2=0;
        if(!lock) flag_correct_pass=true; 
        if(size_str*8>COL_NO){
            counter_timer++;
            //Scrolling the screen if enough time is passed
            if(counter_timer==120){
                flag_scroll=true;
                counter_timer=0;
           }
        }
        k++; 
        if(k==COL_NO+1) k=0;     
    }
}

//USART Receive Interrupt
interrupt [USART_RXC] void usart_rx_isr(void)
{
    temp_uart=UDR;
    flag_connected=true; //As a character is received it means the module is connected
    
    //Determining the first character('+') of the phone number
    if(flag_sms && temp_uart=='+' && counter_char>=4 && counter_char<=20)
        flag_phone=true;
    
    if(flag_phone){
        //Determining the last character of the phone number
        if(temp_uart=='"') flag_phone=false;
        else{
            phone_buffer[counter_phone]=temp_uart;
            counter_phone++;
        }
    }
    
    /*Ignoring the Additional information which GSM module sends
    (like date of received SMS)*/ 
    if(!flag_sms || (flag_sms && counter_char==49)){
        if(temp_uart==13 && !flag_r) flag_r=true;
        else if(flag_r && temp_uart=='\r') {
            //Initializing Variables and Flags
            counter_buffer=0;
            flag_r=false;
            flag_scroll=false;
            counter_timer=0;
            flag_eos=true; //End-Of-String
            counter_char=0; 
            counter_lock=0;
            lock=true;
        }
        
        //Ignoring '\r', '\n' characters   
        if(temp_uart!='\n' && temp_uart!='\r'){
            //Checking that the password sent with SMS in correct or not
            if(!flag_sms || (flag_sms && !lock)){
                flag_eos=false;
                sms_buffer[counter_buffer]=temp_uart;
                for(j=0; j<ROW_NO/2; j++){
                    temp1_dot[ROW_NO/2*counter_buffer+j]=FONT[ROW_NO*char_to_FONTindex(sms_buffer[counter_buffer])+2*j];
                    temp0_dot[ROW_NO/2*counter_buffer+j]=FONT[ROW_NO*char_to_FONTindex(sms_buffer[counter_buffer])+2*j+1];
                }
                sms_buffer[counter_buffer]=0; 
                counter_buffer++;
                //Replacing characters if the maximum capacity is reached
                if(counter_buffer==SMS_MAX_SIZE) counter_buffer=0;
                size_str=counter_buffer;
            }
            if(flag_sms && lock){
                if(temp_uart=='-' && counter_lock==strlen(LOCK_PATTERN)){
                    lock=false;
                }
                
                if(temp_uart==LOCK_PATTERN[counter_lock] && counter_lock<strlen(LOCK_PATTERN)){
                    counter_lock++;            
                } 
            }
        }
    }
    else if(flag_sms) counter_char++;
}

void main(void)
{
    DDRA=0xFF; 
    PORTA=0x00;

    DDRB=0x0C;
    PORTB=0x00;

    DDRC=0xFF;
    PORTC=0x00;

    DDRD=0x00;
    PORTD=0x03;

    TCCR0=(1<<CS01)|(1<<WGM01); // Clock value: 1000.000 kHz
    TCNT0=0x00;
    OCR0=0x63; // Timer Period: 0.1 ms
    TIMSK=(1<<OCIE0); // Timer0: CTC mode
    
    UCSRA=0x00; // 8 Data, 1 Stop, No Parity
    UCSRB=(1<<RXCIE)|(1<<RXEN)|(1<<TXEN); // UART Receiver: On , UART Transmitter: On
    UCSRC=(1<<URSEL)|(1<<UCSZ1)|(1<<UCSZ0);
    UBRRH=0x00;
    UBRRL=0x33; // UART Baud Rate: 9600

    #asm("sei")

    reset_screen();
    init_screen();

    while (1)
        {
            //Checking the GSM module connection to the board
            if(!flag_connected){
                gsm_module_init();
            }

            /*Scrolling the screen if flag_scroll gets TRUE value and
            the end-of-string is reached*/
            if(flag_scroll && flag_eos){
                scroll_screen();
                flag_scroll=false;
            }
            
            /*For sending the Handshake SMS if correct password is sent and
            program has entered the timer interrupt to show the sent message*/ 
            if(flag_correct_pass){
                delay_ms(500);
                //Ignoring OK or ERROR responses (disabling UART receive interrupt)
                UCSRB&=~(1<<RXEN);           
                printf("AT+CMGS=%c%s%c\r\n",34,phone_buffer,34);
                delay_ms(1000);
                printf("Password is correct. Message is on the Notice Board!%c\r\n",CTRL_Z);
                delay_ms(500);
                UCSRB|=(1<<RXEN);
                flag_correct_pass=false;
                lock=true;
            }   
        }
}

